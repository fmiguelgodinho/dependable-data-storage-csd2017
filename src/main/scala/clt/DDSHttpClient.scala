package clt

import akka.actor.{ Actor, ActorLogging }
import akka.http.scaladsl.{ Http, HttpExt }
import akka.http.scaladsl.model._
import akka.http.scaladsl.model.HttpMethods._
import akka.http.scaladsl.model.MediaTypes._
import akka.stream.{ ActorMaterializer, ActorMaterializerSettings }
import akka.util.ByteString

import scala.collection.JavaConverters._
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.Failure
import scala.util.Success
import scala.util.Random
import scala.concurrent.duration._

import utils.Utils
import com.typesafe.sslconfig.akka.AkkaSSLConfig
import javax.net.ssl.SSLContext
import akka.stream.scaladsl.Flow
import akka.stream.scaladsl.Sink
import akka.stream.scaladsl.Source
import java.io.FileInputStream
import javax.net.ssl.KeyManagerFactory
import java.security.KeyStore
import java.io.InputStream
import java.io.File
import javax.net.ssl.TrustManagerFactory
import java.security.SecureRandom
import akka.http.scaladsl.HttpsConnectionContext
import akka.http.scaladsl.ConnectionContext
import scala.concurrent.Await
import akka.util.Timeout
import akka.stream.TLSClientAuth
import dds.exceptions.ByzUnknownReplyException
import org.jboss.netty.handler.timeout.TimeoutException
import java.util.concurrent.TimeUnit
import scala.collection.immutable.HashSet
import javax.xml.bind.DatatypeConverter

import hlib.hj.mlib._
import javax.crypto.SecretKey
import java.math.BigInteger
import java.security.KeyPair
import java.security.interfaces.RSAPublicKey
import java.security.interfaces.RSAPrivateKey
import java.security.PrivateKey
import java.util.Base64
import java.security.PublicKey
import com.typesafe.config.ConfigRenderOptions
import utils.SJHomoLibProvider

class DDSHttpClient(endpoints: List[String]) extends Actor with SJHomoLibProvider {
  
  implicit val system = context.system
  final implicit val materializer: ActorMaterializer = ActorMaterializer()
  
  // Constants
  private val SSL_KEY_STORE = context.system.settings.config.getString("security.key-store")
  private val SSL_KEY_STORE_PW = context.system.settings.config.getString("security.key-store-password").toCharArray
  private val TIMEOUT_PERIOD_MS = context.system.settings.config.getInt("io.http-requests-timeout-period")
  private val DEBUGGING_ENABLED = context.system.settings.config.getBoolean("client-side-debugging")
  private val SSL_CONTEXT = system.settings.config.getString("security.ssl-context-protocol")
  private val ENABLED_PROTOCOLS = system.settings.config.getStringList("security.enabled-protocols").asScala.toIndexedSeq
  private val ENABLED_CIPHERS = system.settings.config.getStringList("security.enabled-ciphersuites").asScala.toIndexedSeq
  private val FIXED_COLUMNS = system.settings.config.getInt("io.data-table.fixed-nr-of-columns")
  private val ENABLE_HENCRYPTION = system.settings.config.getBoolean("io.data-table.enable-homomorphic-encryption")
  private val HENCRYPTION_COLUMNS = system.settings.config.getStringList("io.data-table.fixed-columns-hcrypt").asScala.toList
  private val HENCRYPTION_KEYS = context.system.settings.config.getObject("security.homomorphic-encryption-keys").unwrapped

  
  // HTTPS connections to the system's proxies ------------------------------------------------------------------------------------------
  private var httpsChannels = Map[String, Flow[HttpRequest, HttpResponse, Future[Http.OutgoingConnection]]]()
  // Allows to load balance to any proxy
  def deferTo = httpsChannels.keys.toList(Random.nextInt(httpsChannels.keySet.size))
  // Setups HTTPS
  def setupHttps(ks: KeyStore) = {
    // setup ssl context
    val sslContext: SSLContext = SSLContext.getInstance(SSL_CONTEXT)

    // init key manager
    val kmf: KeyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm)
    kmf.init(ks, SSL_KEY_STORE_PW)

    // init trust manager
    val tmf: TrustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm)
    tmf.init(ks)

    // init ssl
    sslContext.init(kmf.getKeyManagers, tmf.getTrustManagers, new SecureRandom)

    // setup a https connection flow
    val httpsContext = ConnectionContext.https(sslContext, Some(ENABLED_CIPHERS), Some(ENABLED_PROTOCOLS), Some(TLSClientAuth.Need), None)
    // establish a tunnel to each proxy
    for (proxy <- endpoints) {
      httpsChannels += proxy -> Http().outgoingConnectionHttps(proxy, connectionContext = httpsContext)
    }
  }
  
  // Client keys generated by the server ------------------------------------------------------------------------------------------------
  private var myKeys = HashSet[String]()
  // if we have a key that was returned to us by the server, use it
  // otherwise, create a random string
  def getKey = {
      if (myKeys.isEmpty) {
        // generate a dummy key, just for testing purposes, it will usually result in 404 codes
        val buf = Array.ofDim[Byte](128)
        Random.nextBytes(buf)
        buf.map("%02X" format _).mkString
      } else {
        myKeys.toList(Random.nextInt(myKeys size))
      }
  }
  
  // padding functions
  def pad(item:Any) = "\"" + item + "\""
  def padFully(list:List[Any]) = list map { item => pad(item) }
  
  override def preStart {
    
    // load keystore according to config
    val ks: KeyStore = KeyStore.getInstance("JKS")
    val keystore: InputStream = new FileInputStream(new File(SSL_KEY_STORE))
    ks.load(keystore, SSL_KEY_STORE_PW)
    
    // setup https to proxy servers before starting actor
    setupHttps(ks)
    
    if (ENABLE_HENCRYPTION) {
        // load homomorphic encryption keys from cfg
        loadKeys(HENCRYPTION_KEYS)
    }
  }

  def receive = {
    case Digest(payload) =>

      var totalTime = 0
      var startTime = System.currentTimeMillis()

      for (instruction <- payload) {

        var success = false
        var attempts = 0
        
        // get a proxy and a key to request
        var targetUrl = deferTo
        val keyToRequest = getKey

        while (!success) {

          try {

            var url = "https://" + targetUrl + "/"

            val request = instruction match {

              case GetSet() => {
                url += "GetSet/" + keyToRequest
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(uri = url)
              }

              case PutSet(set) => {
                url += "PutSet"
                if (set.isEmpty) {
                  if (DEBUGGING_ENABLED) println("POST " + url + " Content: null")
                  
                  HttpRequest(POST, uri = url)
                } else {
                  val payload = if (ENABLE_HENCRYPTION) encryptFully(set.get, FIXED_COLUMNS, HENCRYPTION_COLUMNS) else set.get
                  var json = padFully(payload).mkString("{\"contents\": [", ", ", "] }")
                  if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)
                  
                  HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
                }

              }

              case AddElement(elem) => {
                url += "AddElement/" + keyToRequest
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "None") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("PUT " + url + " Content: " + json)

                HttpRequest(PUT, uri = url, entity = HttpEntity(`application/json`, json))
              }

              case RemoveSet() => {
                url += "RemoveSet/" + keyToRequest
                if (DEBUGGING_ENABLED) println("DELETE " + url)

                HttpRequest(DELETE, uri = url)
              }

              case WriteElem(elem, pos) => {
                url += "WriteElement/" + keyToRequest + "?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) {
                  if (pos >= FIXED_COLUMNS) encrypt(elem, "None") else encrypt(elem, HENCRYPTION_COLUMNS(pos))
                } else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("PUT " + url + " Content: " + json)

                HttpRequest(PUT, uri = url, entity = HttpEntity(`application/json`, json))
              }

              case ReadElem(pos) => {
                url += "ReadElement/" + keyToRequest + "?position=" + pos
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }

              case IsElement(elem) => {
                url += "IsElement/" + keyToRequest
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "CHE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case Sum(pos) => {
                url += "Sum?key1=" + keyToRequest + "&key2=" + getKey + "&position=" + pos
                if (ENABLE_HENCRYPTION) url += "&nsqr=" + PSSEKey.get.getNsquare
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case SumAll(pos) => {
                url += "SumAll?position=" + pos
                if (ENABLE_HENCRYPTION) url += "&nsqr=" + PSSEKey.get.getNsquare
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case Mult(pos) => {
                url += "Mult?key1=" + keyToRequest + "&key2=" + getKey + "&position=" + pos
                if (ENABLE_HENCRYPTION) url += "&pubkey=" + DatatypeConverter.printHexBinary(MSEKey.get.getPublic.getEncoded)
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case MultAll(pos) => {
                url += "MultAll?position=" + pos 
                if (ENABLE_HENCRYPTION) url += "&pubkey=" + DatatypeConverter.printHexBinary(MSEKey.get.getPublic.getEncoded)
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case OrderLS(pos) => {
                url += "OrderLS?position=" + pos
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case OrderSL(pos) => {
                url += "OrderSL?position=" + pos
                if (DEBUGGING_ENABLED) println("GET " + url)

                HttpRequest(GET, uri = url)
              }
              
              case SearchEq(pos, elem) => {
                url += "SearchEq?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchNEq(pos, elem) => {
                url += "SearchNEq?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchGt(pos, elem) => {
                url += "SearchGt?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchGtEq(pos, elem) => {
                url += "SearchGtEq?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchLt(pos, elem) => {
                url += "SearchLt?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchLtEq(pos, elem) => {
                url += "SearchLtEq?position=" + pos
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "OPE") else elem
                var json = "{ \"value\": " + pad(payload) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchEntry(elem) => {
                url += "SearchEntry/"
                val payload = if (ENABLE_HENCRYPTION) encrypt(elem, "CHE") else elem
                var json = "{ \"value\": " + pad(payload) + "}"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
              
              case SearchEntryAND(elem1, elem2, elem3) => {
                url += "SearchEntryAND/"
                val payload = if (ENABLE_HENCRYPTION) (encrypt(elem1, "CHE"), encrypt(elem2, "CHE"), encrypt(elem3, "CHE")) else (elem1, elem2, elem3)
                var json = "{ \"value1\": " + pad(payload._1) + ", \"value2\": " + pad(payload._2) + ", \"value3\": " + pad(payload._3) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
                            
              case SearchEntryOR(elem1, elem2, elem3) => {
                url += "SearchEntryOR/"
                val payload = if (ENABLE_HENCRYPTION) (encrypt(elem1, "CHE"), encrypt(elem2, "CHE"), encrypt(elem3, "CHE")) else (elem1, elem2, elem3)
                var json = "{ \"value1\": " + pad(payload._1) + ", \"value2\": " + pad(payload._2) + ", \"value3\": " + pad(payload._3) + " }"
                if (DEBUGGING_ENABLED) println("POST " + url + " Content: " + json)

                HttpRequest(POST, uri = url, entity = HttpEntity(`application/json`, json))
              }
            }

            // send the request via HTTPS channel
            val flow = httpsChannels.get(targetUrl).get
            val response = Source.single(request).via(flow).runWith(Sink.head)

            implicit val timeout = Timeout(TIMEOUT_PERIOD_MS millis)
            Await.result(response, timeout.duration) match {
              case response: HttpResponse =>
                if (DEBUGGING_ENABLED) println("HTTP " + response.status + ": " + response.httpMessage)

                if (response.status.intValue == 200) {

                  instruction match {

                    // if we're making a put set, this is a put set reply
                    // and we need to save the server generated sha512 key
                    case PutSet(set) =>
                      response.entity match {
                        case HttpEntity.Strict(contentType, data) =>
                          val sha512Key = data.utf8String
                          myKeys += sha512Key

                        case _ => // ignore
                      }

                    // if we're making a remove set, this is a remove set reply
                    // and we need to remove our particular key
                    case RemoveSet() =>
                      myKeys -= keyToRequest

                    case _ => // ignore
                    
                  }
                }
                success = true
              case _ =>
                throw new ByzUnknownReplyException
            }

          } catch {
            case t @ (_: java.util.concurrent.TimeoutException |
                      _: scala.concurrent.TimeoutException |
                      _: ByzUnknownReplyException) =>

              attempts += 1
              if (attempts == 3) {
                // this server has failed too many times
                // it's no longer trustworthy
                httpsChannels -= targetUrl
                // reset attempt count and reset target proxy
                attempts = 0
                targetUrl = deferTo
              }
          }
        }
      }

      val totalRunningTimeMillis = System.currentTimeMillis - startTime
      val totalRunningTimeSeconds = totalRunningTimeMillis / 1000.0 // dividing by 1000 to get seconds
      println("\nResults:")
      println("\tRunning time = " + totalRunningTimeMillis + " ms")
      println("\t#ops = " + payload.size + " ops")
      println("\tTotal ops/s = " + payload.size / totalRunningTimeSeconds + " ops/s")
  }
}